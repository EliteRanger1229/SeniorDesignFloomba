import cv2
# Renamed from jil.py to PD_main.py
import json
import os
import threading
import time
import platform
import ssl
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
from queue import Queue
from urllib.parse import urlparse

# ---------------------------
# Simple SSE broadcast server
# ---------------------------
subscribers_lock = threading.Lock()
subscribers = []  # list[Queue]

# MQTT publisher (optional; enabled via env)
_mqtt_publisher = None
_mqtt_initialized = False


def _register_client_queue():
    q = Queue(maxsize=16)
    with subscribers_lock:
        subscribers.append(q)
    return q


def _unregister_client_queue(q):
    with subscribers_lock:
        if q in subscribers:
            subscribers.remove(q)


def broadcast_event(event_dict):
    # Fan-out to all subscriber queues without blocking the detector loop
    with subscribers_lock:
        for q in list(subscribers):
            try:
                q.put_nowait(event_dict)
            except Exception:
                try:
                    _ = q.get_nowait()
                    q.put_nowait(event_dict)
                except Exception:
                    pass
    # Also enqueue for MQTT if configured (lazy init)
    try:
        global _mqtt_publisher, _mqtt_initialized
        if not _mqtt_initialized:
            _mqtt_initialized = True
            mqtt_url = os.getenv("MQTT_URL")
            if mqtt_url:
                _mqtt_publisher = MqttPublisher(
                    url=mqtt_url,
                    user=os.getenv("MQTT_USER"),
                    password=os.getenv("MQTT_PASS"),
                    topic=os.getenv("MQTT_TOPIC"),
                    qos=os.getenv("MQTT_QOS", "1"),
                    client_id=os.getenv("MQTT_CLIENT_ID"),
                    cafile=os.getenv("MQTT_CAFILE"),
                    drone_id=os.getenv("DRONE_ID") or platform.node(),
                )
                _mqtt_publisher.start()
        if _mqtt_publisher is not None:
            _mqtt_publisher.enqueue(event_dict)
    except Exception:
        pass


class Handler(BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        # Keep server quiet in console
        return

    def do_GET(self):
        if self.path in ("/", "/index.html"):
            self._serve_index()
            return
        if self.path == "/events":
            self._serve_sse()
            return
        self.send_response(404)
        self.end_headers()

    def _serve_index(self):
        index_path = os.path.join(os.path.dirname(__file__), "web", "index.html")
        try:
            with open(index_path, "rb") as f:
                content = f.read()
            self.send_response(200)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self.send_header("Content-Length", str(len(content)))
            self.end_headers()
            self.wfile.write(content)
        except FileNotFoundError:
            self.send_response(200)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self.end_headers()
            self.wfile.write(b"<h1>Person Detection</h1><p>Missing web/index.html</p>")

    def _serve_sse(self):
        self.send_response(200)
        self.send_header("Content-Type", "text/event-stream")
        self.send_header("Cache-Control", "no-cache")
        self.send_header("Connection", "keep-alive")
        self.end_headers()
        client_q = _register_client_queue()
        # Initial ping to open the stream
        try:
            self.wfile.write(b": connected\n\n")
            self.wfile.flush()
        except Exception:
            _unregister_client_queue(client_q)
            return
        try:
            while True:
                data = client_q.get()
                payload = ("data: " + json.dumps(data) + "\n\n").encode("utf-8")
                self.wfile.write(payload)
                self.wfile.flush()
        except Exception:
            pass
        finally:
            _unregister_client_queue(client_q)


def start_http_server(host="0.0.0.0", port=8000):
    server = ThreadingHTTPServer((host, port), Handler)
    t = threading.Thread(target=server.serve_forever, daemon=True)
    t.start()
    return server


# ---------------------------
# MQTT Publish (optional)
# ---------------------------
class MqttPublisher:
    def __init__(self, url, user=None, password=None, topic=None, qos=1, client_id=None, cafile=None, drone_id=None):
        self.url = url
        self.user = user
        self.password = password
        self.topic = topic
        self.qos = int(qos or 1)
        self.client_id = client_id
        self.cafile = cafile
        self.drone_id = drone_id or platform.node() or "drone"
        self._q = Queue(maxsize=256)
        self._connected_evt = threading.Event()
        self._stop_evt = threading.Event()
        self._thread = None
        self._client = None

    def start(self):
        # Create MQTT client (explicit Callback API v1 to avoid warnings on paho-mqtt v2)
        try:
            from paho.mqtt.client import Client, CallbackAPIVersion
            self._client = Client(client_id=self.client_id or f"jil-{self.drone_id}", callback_api_version=CallbackAPIVersion.VERSION2)
        except Exception:
            try:
                import paho.mqtt.client as mqtt
            except Exception as e:
                print(f"[mqtt] paho-mqtt not available: {e}. MQTT disabled.")
                return False
            self._client = mqtt.Client(client_id=self.client_id or f"jil-{self.drone_id}")

        parsed = urlparse(self.url)
        scheme = (parsed.scheme or "mqtt").lower()
        host = parsed.hostname or "localhost"
        port = parsed.port or (8883 if scheme in ("mqtts", "ssl", "tls") else 1883)

        if self.user:
            self._client.username_pw_set(self.user, self.password or None)

        if scheme in ("mqtts", "ssl", "tls"):
            ctx = ssl.create_default_context(cafile=self.cafile) if self.cafile else ssl.create_default_context()
            self._client.tls_set_context(ctx)

        def on_connect(client, userdata, flags, rc, properties=None):
            if rc == 0:
                self._connected_evt.set()
                print("[mqtt] connected")
            else:
                print(f"[mqtt] connect failed rc={rc}")

        def on_disconnect(client, userdata, rc, properties=None):
            self._connected_evt.clear()
            print(f"[mqtt] disconnected rc={rc}")

        self._client.on_connect = on_connect
        self._client.on_disconnect = on_disconnect

        self._client.connect_async(host, port, keepalive=30)
        self._client.loop_start()

        self._thread = threading.Thread(target=self._worker, name="mqtt-publisher", daemon=True)
        self._thread.start()
        return True
